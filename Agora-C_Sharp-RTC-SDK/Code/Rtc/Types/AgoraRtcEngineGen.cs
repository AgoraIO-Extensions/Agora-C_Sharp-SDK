#region Generated by `terra/node/src/rtc/struct_enumz/renderers.ts`. DO NOT MODIFY BY HAND.
#endregion

using System;
using Agora.Rtc.LitJson;
using view_t = System.UInt64;
using uint8_t = System.Byte;
using int16_t = System.Int16;

namespace Agora.Rtc
{
    ///
    /// <summary>
    /// Device type.
    /// </summary>
    ///
    public enum MEDIA_DEVICE_TYPE
    {
        ///
        /// <summary>
        /// -1: Unknown device type.
        /// </summary>
        ///
        UNKNOWN_AUDIO_DEVICE = -1,

        ///
        /// <summary>
        /// 0: Audio playback device.
        /// </summary>
        ///
        AUDIO_PLAYOUT_DEVICE = 0,

        ///
        /// <summary>
        /// 1: Audio recording device.
        /// </summary>
        ///
        AUDIO_RECORDING_DEVICE = 1,

        ///
        /// <summary>
        /// 2: Video rendering device (graphics card).
        /// </summary>
        ///
        VIDEO_RENDER_DEVICE = 2,

        ///
        /// <summary>
        /// 3: Video capture device.
        /// </summary>
        ///
        VIDEO_CAPTURE_DEVICE = 3,

        ///
        /// <summary>
        /// 4: Audio application playback device.
        /// </summary>
        ///
        AUDIO_APPLICATION_PLAYOUT_DEVICE = 4,

        ///
        /// <summary>
        /// (macOS only) 5: Virtual audio playback device (virtual sound card).
        /// </summary>
        ///
        AUDIO_VIRTUAL_PLAYOUT_DEVICE = 5,

        ///
        /// <summary>
        /// (macOS only) 6: Virtual audio recording device (virtual sound card).
        /// </summary>
        ///
        AUDIO_VIRTUAL_RECORDING_DEVICE = 6,

    }

    ///
    /// <summary>
    /// Music file playback state.
    /// </summary>
    ///
    public enum AUDIO_MIXING_STATE_TYPE
    {
        ///
        /// <summary>
        /// 710: Music file is playing normally.
        /// </summary>
        ///
        AUDIO_MIXING_STATE_PLAYING = 710,

        ///
        /// <summary>
        /// 711: Music file playback is paused.
        /// </summary>
        ///
        AUDIO_MIXING_STATE_PAUSED = 711,

        ///
        /// <summary>
        /// 713: Music file playback stopped.
        /// This state may be caused by:
        ///  AUDIO_MIXING_REASON_ALL_LOOPS_COMPLETED(723)
        ///  AUDIO_MIXING_REASON_STOPPED_BY_USER(724)
        /// </summary>
        ///
        AUDIO_MIXING_STATE_STOPPED = 713,

        ///
        /// <summary>
        /// 714: Music file playback failed.
        /// This state may be caused by:
        ///  AUDIO_MIXING_REASON_CAN_NOT_OPEN(701)
        ///  AUDIO_MIXING_REASON_TOO_FREQUENT_CALL(702)
        ///  AUDIO_MIXING_REASON_INTERRUPTED_EOF(703)
        /// </summary>
        ///
        AUDIO_MIXING_STATE_FAILED = 714,

    }

    ///
    /// <summary>
    /// Reason for music file playback state change. Reported in the OnAudioMixingStateChanged callback.
    /// </summary>
    ///
    public enum AUDIO_MIXING_REASON_TYPE
    {
        ///
        /// <summary>
        /// 701: Failed to open music file. For example, the local music file does not exist, the file format is not supported, or the online music file URL is inaccessible.
        /// </summary>
        ///
        AUDIO_MIXING_REASON_CAN_NOT_OPEN = 701,

        ///
        /// <summary>
        /// 702: Music file opened too frequently. If you need to call startAudioMixing multiple times, ensure the interval between calls is greater than 500 ms.
        /// </summary>
        ///
        AUDIO_MIXING_REASON_TOO_FREQUENT_CALL = 702,

        ///
        /// <summary>
        /// 703: Music file playback interrupted.
        /// </summary>
        ///
        AUDIO_MIXING_REASON_INTERRUPTED_EOF = 703,

        ///
        /// <summary>
        /// 721: One loop of music file playback completed.
        /// </summary>
        ///
        AUDIO_MIXING_REASON_ONE_LOOP_COMPLETED = 721,

        ///
        /// <summary>
        /// 723: All loops of music file playback completed.
        /// </summary>
        ///
        AUDIO_MIXING_REASON_ALL_LOOPS_COMPLETED = 723,

        ///
        /// <summary>
        /// 724: Music file playback stopped successfully by calling StopAudioMixing.
        /// </summary>
        ///
        AUDIO_MIXING_REASON_STOPPED_BY_USER = 724,

        ///
        /// @ignore
        ///
        AUDIO_MIXING_REASON_RESUMED_BY_USER = 726,

        ///
        /// <summary>
        /// 0: Music file opened successfully.
        /// </summary>
        ///
        AUDIO_MIXING_REASON_OK = 0,

    }

    ///
    /// @ignore
    ///
    public enum INJECT_STREAM_STATUS
    {
        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_START_SUCCESS = 0,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_START_ALREADY_EXISTS = 1,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_START_UNAUTHORIZED = 2,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_START_TIMEDOUT = 3,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_START_FAILED = 4,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_STOP_SUCCESS = 5,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_STOP_NOT_FOUND = 6,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_STOP_UNAUTHORIZED = 7,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_STOP_TIMEDOUT = 8,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_STOP_FAILED = 9,

        ///
        /// @ignore
        ///
        INJECT_STREAM_STATUS_BROKEN = 10,

    }

    ///
    /// <summary>
    /// Center frequencies of voice equalization bands.
    /// </summary>
    ///
    public enum AUDIO_EQUALIZATION_BAND_FREQUENCY
    {
        ///
        /// <summary>
        /// 0: 31 Hz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_31 = 0,

        ///
        /// <summary>
        /// 1: 62 Hz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_62 = 1,

        ///
        /// <summary>
        /// 2: 125 Hz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_125 = 2,

        ///
        /// <summary>
        /// 3: 250 Hz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_250 = 3,

        ///
        /// <summary>
        /// 4: 500 Hz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_500 = 4,

        ///
        /// <summary>
        /// 5: 1 kHz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_1K = 5,

        ///
        /// <summary>
        /// 6: 2 kHz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_2K = 6,

        ///
        /// <summary>
        /// 7: 4 kHz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_4K = 7,

        ///
        /// <summary>
        /// 8: 8 kHz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_8K = 8,

        ///
        /// <summary>
        /// 9: 16 kHz
        /// </summary>
        ///
        AUDIO_EQUALIZATION_BAND_16K = 9,

    }

    ///
    /// <summary>
    /// Audio reverb types.
    /// </summary>
    ///
    public enum AUDIO_REVERB_TYPE
    {
        ///
        /// <summary>
        /// 0: Original sound intensity, also known as dry signal, range [-20,10], unit: dB.
        /// </summary>
        ///
        AUDIO_REVERB_DRY_LEVEL = 0,

        ///
        /// <summary>
        /// 1: Early reflection signal intensity, also known as wet signal, range [-20,10], unit: dB.
        /// </summary>
        ///
        AUDIO_REVERB_WET_LEVEL = 1,

        ///
        /// <summary>
        /// 2: Room size for desired reverb effect. Generally, the larger the room, the stronger the reverb. Range [0,100], unit: dB.
        /// </summary>
        ///
        AUDIO_REVERB_ROOM_SIZE = 2,

        ///
        /// <summary>
        /// 3: Initial delay length of wet signal, range [0,200], unit: milliseconds.
        /// </summary>
        ///
        AUDIO_REVERB_WET_DELAY = 3,

        ///
        /// <summary>
        /// 4: Intensity of reverb duration, range [0,100].
        /// </summary>
        ///
        AUDIO_REVERB_STRENGTH = 4,

    }

    ///
    /// <summary>
    /// Options for handling audio/video stream fallback under poor network conditions.
    /// </summary>
    ///
    public enum STREAM_FALLBACK_OPTIONS
    {
        ///
        /// <summary>
        /// 0: Do not apply fallback to audio/video streams, but the quality of the streams is not guaranteed.
        /// </summary>
        ///
        STREAM_FALLBACK_OPTION_DISABLED = 0,

        ///
        /// <summary>
        /// 1: Receive only the low-quality video stream (low resolution, low bitrate).
        /// </summary>
        ///
        STREAM_FALLBACK_OPTION_VIDEO_STREAM_LOW = 1,

        ///
        /// <summary>
        /// 2: Under poor network conditions, first attempt to receive only the low-quality video stream; if the network is too poor to display video, fallback to receiving only the subscribed audio stream.
        /// </summary>
        ///
        STREAM_FALLBACK_OPTION_AUDIO_ONLY = 2,

        ///
        /// @ignore
        ///
        STREAM_FALLBACK_OPTION_VIDEO_STREAM_LAYER_1 = 3,

        ///
        /// @ignore
        ///
        STREAM_FALLBACK_OPTION_VIDEO_STREAM_LAYER_2 = 4,

        ///
        /// @ignore
        ///
        STREAM_FALLBACK_OPTION_VIDEO_STREAM_LAYER_3 = 5,

        ///
        /// @ignore
        ///
        STREAM_FALLBACK_OPTION_VIDEO_STREAM_LAYER_4 = 6,

        ///
        /// @ignore
        ///
        STREAM_FALLBACK_OPTION_VIDEO_STREAM_LAYER_5 = 7,

        ///
        /// @ignore
        ///
        STREAM_FALLBACK_OPTION_VIDEO_STREAM_LAYER_6 = 8,

    }

    ///
    /// @ignore
    ///
    public enum PRIORITY_TYPE
    {
        ///
        /// @ignore
        ///
        PRIORITY_HIGH = 50,

        ///
        /// @ignore
        ///
        PRIORITY_NORMAL = 100,

    }

    ///
    /// <summary>
    /// Statistics of the local video stream.
    /// </summary>
    ///
    public class LocalVideoStats
    {
        ///
        /// <summary>
        /// The ID of the local user.
        /// </summary>
        ///
        public uint uid;

        ///
        /// <summary>
        /// Actual sending bitrate (Kbps) Excludes bitrate of retransmitted video due to packet loss.
        /// </summary>
        ///
        public int sentBitrate;

        ///
        /// <summary>
        /// Actual sending frame rate (fps). Excludes frame rate of retransmitted video due to packet loss.
        /// </summary>
        ///
        public int sentFrameRate;

        ///
        /// <summary>
        /// Local video capture frame rate (fps).
        /// </summary>
        ///
        public int captureFrameRate;

        ///
        /// <summary>
        /// Local video capture width (px).
        /// </summary>
        ///
        public int captureFrameWidth;

        ///
        /// <summary>
        /// Local video capture height (px).
        /// </summary>
        ///
        public int captureFrameHeight;

        ///
        /// <summary>
        /// Camera capture frame rate (fps) adjusted by the SDK's built-in video capture adapter (regulator). The regulator adjusts the camera capture frame rate based on the video encoding configuration.
        /// </summary>
        ///
        public int regulatedCaptureFrameRate;

        ///
        /// <summary>
        /// Camera capture width (px) adjusted by the SDK's built-in video capture adapter (regulator). The regulator adjusts the camera capture resolution based on the video encoding configuration.
        /// </summary>
        ///
        public int regulatedCaptureFrameWidth;

        ///
        /// <summary>
        /// Camera capture height (px) adjusted by the SDK's built-in video capture adapter (regulator). The regulator adjusts the camera capture resolution based on the video encoding configuration.
        /// </summary>
        ///
        public int regulatedCaptureFrameHeight;

        ///
        /// <summary>
        /// Output frame rate of the local video encoder, in fps.
        /// </summary>
        ///
        public int encoderOutputFrameRate;

        ///
        /// <summary>
        /// Video encoding width (px).
        /// </summary>
        ///
        public int encodedFrameWidth;

        ///
        /// <summary>
        /// Video encoding height (px).
        /// </summary>
        ///
        public int encodedFrameHeight;

        ///
        /// <summary>
        /// Output frame rate of the local video renderer, in fps.
        /// </summary>
        ///
        public int rendererOutputFrameRate;

        ///
        /// <summary>
        /// Target encoding bitrate (Kbps) of the current encoder. This value is estimated by the SDK based on the current network conditions.
        /// </summary>
        ///
        public int targetBitrate;

        ///
        /// <summary>
        /// Target encoding frame rate (fps) of the current encoder.
        /// </summary>
        ///
        public int targetFrameRate;

        ///
        /// <summary>
        /// Adaptation status of local video quality (based on target frame rate and target bitrate) during the statistical period. See QUALITY_ADAPT_INDICATION.
        /// </summary>
        ///
        public QUALITY_ADAPT_INDICATION qualityAdaptIndication;

        ///
        /// <summary>
        /// Video encoding bitrate (Kbps). Excludes bitrate of retransmitted video due to packet loss.
        /// </summary>
        ///
        public int encodedBitrate;

        ///
        /// <summary>
        /// Number of video frames sent, cumulative value.
        /// </summary>
        ///
        public int encodedFrameCount;

        ///
        /// <summary>
        /// Video codec type. See VIDEO_CODEC_TYPE.
        /// </summary>
        ///
        public VIDEO_CODEC_TYPE codecType;

        ///
        /// <summary>
        /// Video packet loss rate (%) from the local end to the Agora edge server before network resilience.
        /// </summary>
        ///
        public ushort txPacketLossRate;

        ///
        /// <summary>
        /// Brightness level of the locally captured video. See CAPTURE_BRIGHTNESS_LEVEL_TYPE.
        /// </summary>
        ///
        public CAPTURE_BRIGHTNESS_LEVEL_TYPE captureBrightnessLevel;

        ///
        /// @ignore
        ///
        public bool dualStreamEnabled;

        ///
        /// <summary>
        /// Local video encoder acceleration type.
        ///  0: Uses software encoding, no acceleration.
        ///  1: Uses hardware encoding for acceleration.
        /// </summary>
        ///
        public int hwEncoderAccelerating;

        ///
        /// @ignore
        ///
        public VideoDimensions[] simulcastDimensions;

        ///
        /// @ignore
        ///
        public int encodedFrameDepth;

        public LocalVideoStats(uint uid, int sentBitrate, int sentFrameRate, int captureFrameRate, int captureFrameWidth, int captureFrameHeight, int regulatedCaptureFrameRate, int regulatedCaptureFrameWidth, int regulatedCaptureFrameHeight, int encoderOutputFrameRate, int encodedFrameWidth, int encodedFrameHeight, int rendererOutputFrameRate, int targetBitrate, int targetFrameRate, QUALITY_ADAPT_INDICATION qualityAdaptIndication, int encodedBitrate, int encodedFrameCount, VIDEO_CODEC_TYPE codecType, ushort txPacketLossRate, CAPTURE_BRIGHTNESS_LEVEL_TYPE captureBrightnessLevel, bool dualStreamEnabled, int hwEncoderAccelerating, VideoDimensions[] simulcastDimensions, int encodedFrameDepth)
        {
            this.uid = uid;
            this.sentBitrate = sentBitrate;
            this.sentFrameRate = sentFrameRate;
            this.captureFrameRate = captureFrameRate;
            this.captureFrameWidth = captureFrameWidth;
            this.captureFrameHeight = captureFrameHeight;
            this.regulatedCaptureFrameRate = regulatedCaptureFrameRate;
            this.regulatedCaptureFrameWidth = regulatedCaptureFrameWidth;
            this.regulatedCaptureFrameHeight = regulatedCaptureFrameHeight;
            this.encoderOutputFrameRate = encoderOutputFrameRate;
            this.encodedFrameWidth = encodedFrameWidth;
            this.encodedFrameHeight = encodedFrameHeight;
            this.rendererOutputFrameRate = rendererOutputFrameRate;
            this.targetBitrate = targetBitrate;
            this.targetFrameRate = targetFrameRate;
            this.qualityAdaptIndication = qualityAdaptIndication;
            this.encodedBitrate = encodedBitrate;
            this.encodedFrameCount = encodedFrameCount;
            this.codecType = codecType;
            this.txPacketLossRate = txPacketLossRate;
            this.captureBrightnessLevel = captureBrightnessLevel;
            this.dualStreamEnabled = dualStreamEnabled;
            this.hwEncoderAccelerating = hwEncoderAccelerating;
            this.simulcastDimensions = simulcastDimensions;
            this.encodedFrameDepth = encodedFrameDepth;
        }
        public LocalVideoStats()
        {
        }

    }

    ///
    /// <summary>
    /// Audio statistics of a remote user.
    /// </summary>
    ///
    public class RemoteAudioStats
    {
        ///
        /// <summary>
        /// User ID of the remote user.
        /// </summary>
        ///
        public uint uid;

        ///
        /// <summary>
        /// Audio stream quality sent by the remote user. See QUALITY_TYPE.
        /// </summary>
        ///
        public int quality;

        ///
        /// <summary>
        /// Network delay from the audio sender to the receiver (ms).
        /// </summary>
        ///
        public int networkTransportDelay;

        ///
        /// <summary>
        /// Network delay from the receiver to the jitter buffer (ms). This parameter is not valid when the receiver is an audience member and ClientRoleOptions 's audienceLatencyLevel is 1.
        /// </summary>
        ///
        public int jitterBufferDelay;

        ///
        /// <summary>
        /// Audio frame loss rate (%) of the remote stream during the reporting interval.
        /// </summary>
        ///
        public int audioLossRate;

        ///
        /// <summary>
        /// Number of audio channels.
        /// </summary>
        ///
        public int numChannels;

        ///
        /// <summary>
        /// Sampling rate of the received remote audio stream during the reporting interval.
        /// </summary>
        ///
        public int receivedSampleRate;

        ///
        /// <summary>
        /// Average bitrate (Kbps) of the received remote audio stream during the reporting interval.
        /// </summary>
        ///
        public int receivedBitrate;

        ///
        /// <summary>
        /// Total duration (ms) of audio freezes after the remote user joins the channel. An audio freeze is defined as a frame loss rate of 4% or higher during a call.
        /// </summary>
        ///
        public int totalFrozenTime;

        ///
        /// <summary>
        /// Percentage (%) of total freeze time relative to the total duration of valid audio. Valid audio duration refers to the time after the remote user joins the channel during which audio is neither stopped nor disabled.
        /// </summary>
        ///
        public int frozenRate;

        ///
        /// <summary>
        /// During the reporting interval, the quality score of the received remote audio stream as assessed by Agora’s real-time audio MOS (Mean Opinion Score) method. The return value ranges from [0, 500]. Divide the value by 100 to get the MOS score, which ranges from 0 to 5. The higher the score, the better the audio quality. MOS Score Audio Quality Greater than 4 Excellent audio quality, clear and smooth. 3.5 - 4 Good audio quality, occasional artifacts, but still clear. 3 - 3.5 Fair audio quality, occasional stutters, not very smooth, requires some attention to understand. 2.5 - 3 Poor audio quality, frequent stutters, requires concentration to understand. 2 - 2.5 Very poor audio quality, occasional noise, partial semantic loss, difficult to communicate. Less than 2 Extremely poor audio quality, frequent noise, significant semantic loss, communication impossible.
        /// </summary>
        ///
        public int mosValue;

        ///
        /// @ignore
        ///
        public uint frozenRateByCustomPlcCount;

        ///
        /// @ignore
        ///
        public uint plcCount;

        ///
        /// @ignore
        ///
        public uint frozenCntByCustom;

        ///
        /// @ignore
        ///
        public uint frozenTimeByCustom;

        ///
        /// <summary>
        /// Valid duration (ms) from the start of the audio call to the current callback.
        /// Valid duration excludes the total time the remote user was muted.
        /// </summary>
        ///
        public int totalActiveTime;

        ///
        /// <summary>
        /// Total publishing duration (ms) of the remote audio stream.
        /// </summary>
        ///
        public int publishDuration;

        ///
        /// <summary>
        /// Subjective quality of experience perceived by the local user when receiving remote audio. See EXPERIENCE_QUALITY_TYPE.
        /// </summary>
        ///
        public int qoeQuality;

        ///
        /// <summary>
        /// Reason for poor subjective experience quality when receiving remote audio. See EXPERIENCE_POOR_REASON.
        /// </summary>
        ///
        public int qualityChangedReason;

        ///
        /// @ignore
        ///
        public uint rxAudioBytes;

        ///
        /// <summary>
        /// End-to-end audio delay (ms), i.e., the total time from when the remote user captures the audio to when the local user starts playing it.
        /// </summary>
        ///
        public int e2eDelay;

        public RemoteAudioStats()
        {
            this.uid = 0;
            this.quality = 0;
            this.networkTransportDelay = 0;
            this.jitterBufferDelay = 0;
            this.audioLossRate = 0;
            this.numChannels = 0;
            this.receivedSampleRate = 0;
            this.receivedBitrate = 0;
            this.totalFrozenTime = 0;
            this.frozenRate = 0;
            this.mosValue = 0;
            this.frozenRateByCustomPlcCount = 0;
            this.plcCount = 0;
            this.frozenCntByCustom = 0;
            this.frozenTimeByCustom = 0;
            this.totalActiveTime = 0;
            this.publishDuration = 0;
            this.qoeQuality = 0;
            this.qualityChangedReason = 0;
            this.rxAudioBytes = 0;
            this.e2eDelay = 0;
        }

        public RemoteAudioStats(uint uid, int quality, int networkTransportDelay, int jitterBufferDelay, int audioLossRate, int numChannels, int receivedSampleRate, int receivedBitrate, int totalFrozenTime, int frozenRate, int mosValue, uint frozenRateByCustomPlcCount, uint plcCount, uint frozenCntByCustom, uint frozenTimeByCustom, int totalActiveTime, int publishDuration, int qoeQuality, int qualityChangedReason, uint rxAudioBytes, int e2eDelay)
        {
            this.uid = uid;
            this.quality = quality;
            this.networkTransportDelay = networkTransportDelay;
            this.jitterBufferDelay = jitterBufferDelay;
            this.audioLossRate = audioLossRate;
            this.numChannels = numChannels;
            this.receivedSampleRate = receivedSampleRate;
            this.receivedBitrate = receivedBitrate;
            this.totalFrozenTime = totalFrozenTime;
            this.frozenRate = frozenRate;
            this.mosValue = mosValue;
            this.frozenRateByCustomPlcCount = frozenRateByCustomPlcCount;
            this.plcCount = plcCount;
            this.frozenCntByCustom = frozenCntByCustom;
            this.frozenTimeByCustom = frozenTimeByCustom;
            this.totalActiveTime = totalActiveTime;
            this.publishDuration = publishDuration;
            this.qoeQuality = qoeQuality;
            this.qualityChangedReason = qualityChangedReason;
            this.rxAudioBytes = rxAudioBytes;
            this.e2eDelay = e2eDelay;
        }
    }

    ///
    /// <summary>
    /// Statistics of the remote video stream.
    /// </summary>
    ///
    public class RemoteVideoStats
    {
        ///
        /// <summary>
        /// User ID specifying which user's video stream.
        /// </summary>
        ///
        public uint uid;

        ///
        /// <summary>
        /// Delay (ms). Deprecated: In audio-video scenarios with A/V sync mechanisms, refer to the networkTransportDelay and jitterBufferDelay members in RemoteAudioStats for video delay data.
        /// </summary>
        ///
        public int delay;

        ///
        /// <summary>
        /// End-to-end video delay (ms). That is, the total time from when the remote user captures the video to when the local user receives and renders it.
        /// </summary>
        ///
        public int e2eDelay;

        ///
        /// <summary>
        /// Width of the video stream (pixels).
        /// </summary>
        ///
        public int width;

        ///
        /// <summary>
        /// Height of the video stream (pixels).
        /// </summary>
        ///
        public int height;

        ///
        /// <summary>
        /// Bitrate (Kbps) received since the last report.
        /// </summary>
        ///
        public int receivedBitrate;

        ///
        /// @ignore
        ///
        public int decoderInputFrameRate;

        ///
        /// <summary>
        /// Output frame rate of the remote video decoder, in fps.
        /// </summary>
        ///
        public int decoderOutputFrameRate;

        ///
        /// <summary>
        /// Output frame rate of the remote video renderer, in fps.
        /// </summary>
        ///
        public int rendererOutputFrameRate;

        ///
        /// <summary>
        /// Packet loss rate (%) of the remote video.
        /// </summary>
        ///
        public int frameLossRate;

        ///
        /// <summary>
        /// Packet loss rate (%) of the remote video after applying anti-packet-loss techniques.
        /// </summary>
        ///
        public int packetLossRate;

        ///
        /// <summary>
        /// Video stream type: high stream or low stream. See VIDEO_STREAM_TYPE.
        /// </summary>
        ///
        public VIDEO_STREAM_TYPE rxStreamType;

        ///
        /// <summary>
        /// Total duration (ms) of video freezes after the remote user joins the channel. During the call, if the video frame rate is set to no less than 5 fps and the interval between two consecutive rendered frames exceeds 500 ms, it is counted as a video freeze.
        /// </summary>
        ///
        public int totalFrozenTime;

        ///
        /// <summary>
        /// Percentage (%) of total freeze time relative to the total duration of valid video. Valid video duration refers to the time after the remote user joins the channel during which video is neither stopped nor disabled.
        /// </summary>
        ///
        public int frozenRate;

        ///
        /// <summary>
        /// Time (ms) that audio leads video. If the value is negative, it means audio lags behind video.
        /// </summary>
        ///
        public int avSyncTimeMs;

        ///
        /// <summary>
        /// Valid video duration (ms).
        /// Total valid video duration refers to the time after the remote user or host joins the channel during which video is neither stopped nor disabled.
        /// </summary>
        ///
        public int totalActiveTime;

        ///
        /// <summary>
        /// Total publishing duration (ms) of the remote video stream.
        /// </summary>
        ///
        public int publishDuration;

        ///
        /// <summary>
        /// Quality of the remote audio stream during the reporting interval. The quality is measured by Agora’s real-time audio MOS (Mean Opinion Score) method. The return value ranges from [0, 500]; divide by 100 to get the MOS score, ranging from 0 to 5. The higher the score, the better the audio quality. The subjective audio quality corresponding to the Agora real-time audio MOS score is as follows:
        ///  Greater than 4: Excellent audio quality, clear and smooth.
        ///  3.5 - 4: Good audio quality, occasional artifacts, but still clear.
        ///  3 - 3.5: Fair audio quality, occasional stutters, not very smooth, requires some attention to understand.
        ///  2.5 - 3: Poor audio quality, frequent stutters, requires concentration to understand.
        ///  2 - 2.5: Very poor audio quality, occasional noise, partial semantic loss, difficult to communicate.
        ///  Less than 2: Extremely poor audio quality, frequent noise, significant semantic loss, communication impossible.
        /// </summary>
        ///
        public int mosValue;

        ///
        /// @ignore
        ///
        public uint rxVideoBytes;

        public RemoteVideoStats(uint uid, int delay, int e2eDelay, int width, int height, int receivedBitrate, int decoderInputFrameRate, int decoderOutputFrameRate, int rendererOutputFrameRate, int frameLossRate, int packetLossRate, VIDEO_STREAM_TYPE rxStreamType, int totalFrozenTime, int frozenRate, int avSyncTimeMs, int totalActiveTime, int publishDuration, int mosValue, uint rxVideoBytes)
        {
            this.uid = uid;
            this.delay = delay;
            this.e2eDelay = e2eDelay;
            this.width = width;
            this.height = height;
            this.receivedBitrate = receivedBitrate;
            this.decoderInputFrameRate = decoderInputFrameRate;
            this.decoderOutputFrameRate = decoderOutputFrameRate;
            this.rendererOutputFrameRate = rendererOutputFrameRate;
            this.frameLossRate = frameLossRate;
            this.packetLossRate = packetLossRate;
            this.rxStreamType = rxStreamType;
            this.totalFrozenTime = totalFrozenTime;
            this.frozenRate = frozenRate;
            this.avSyncTimeMs = avSyncTimeMs;
            this.totalActiveTime = totalActiveTime;
            this.publishDuration = publishDuration;
            this.mosValue = mosValue;
            this.rxVideoBytes = rxVideoBytes;
        }
        public RemoteVideoStats()
        {
        }

    }

    ///
    /// @ignore
    ///
    public class VideoCompositingLayout
    {
        ///
        /// @ignore
        ///
        public int canvasWidth;

        ///
        /// @ignore
        ///
        public int canvasHeight;

        ///
        /// @ignore
        ///
        public string backgroundColor;

        ///
        /// @ignore
        ///
        public Region[] regions;

        ///
        /// @ignore
        ///
        public int regionCount;

        ///
        /// @ignore
        ///
        public string appData;

        ///
        /// @ignore
        ///
        public int appDataLength;

        public VideoCompositingLayout()
        {
            this.canvasWidth = 0;
            this.canvasHeight = 0;
            this.backgroundColor = "";
            this.regions = new Region[0];
            this.regionCount = 0;
            this.appData = "";
            this.appDataLength = 0;
        }

        public VideoCompositingLayout(int canvasWidth, int canvasHeight, string backgroundColor, Region[] regions, int regionCount, string appData, int appDataLength)
        {
            this.canvasWidth = canvasWidth;
            this.canvasHeight = canvasHeight;
            this.backgroundColor = backgroundColor;
            this.regions = regions;
            this.regionCount = regionCount;
            this.appData = appData;
            this.appDataLength = appDataLength;
        }
    }

    ///
    /// @ignore
    ///
    public class Region
    {
        ///
        /// @ignore
        ///
        public uint uid;

        ///
        /// @ignore
        ///
        public double x;

        ///
        /// @ignore
        ///
        public double y;

        ///
        /// @ignore
        ///
        public double width;

        ///
        /// @ignore
        ///
        public double height;

        ///
        /// @ignore
        ///
        public int zOrder;

        ///
        /// @ignore
        ///
        public double alpha;

        ///
        /// @ignore
        ///
        public RENDER_MODE_TYPE renderMode;

        public Region()
        {
            this.uid = 0;
            this.x = 0;
            this.y = 0;
            this.width = 0;
            this.height = 0;
            this.zOrder = 0;
            this.alpha = 1.0;
            this.renderMode = RENDER_MODE_TYPE.RENDER_MODE_HIDDEN;
        }

        public Region(uint uid, double x, double y, double width, double height, int zOrder, double alpha, RENDER_MODE_TYPE renderMode)
        {
            this.uid = uid;
            this.x = x;
            this.y = y;
            this.width = width;
            this.height = height;
            this.zOrder = zOrder;
            this.alpha = alpha;
            this.renderMode = renderMode;
        }
    }

    ///
    /// @ignore
    ///
    public class InjectStreamConfig
    {
        ///
        /// @ignore
        ///
        public int width;

        ///
        /// @ignore
        ///
        public int height;

        ///
        /// @ignore
        ///
        public int videoGop;

        ///
        /// @ignore
        ///
        public int videoFramerate;

        ///
        /// @ignore
        ///
        public int videoBitrate;

        ///
        /// @ignore
        ///
        public AUDIO_SAMPLE_RATE_TYPE audioSampleRate;

        ///
        /// @ignore
        ///
        public int audioBitrate;

        ///
        /// @ignore
        ///
        public int audioChannels;

        public InjectStreamConfig()
        {
            this.width = 0;
            this.height = 0;
            this.videoGop = 30;
            this.videoFramerate = 15;
            this.videoBitrate = 400;
            this.audioSampleRate = AUDIO_SAMPLE_RATE_TYPE.AUDIO_SAMPLE_RATE_48000;
            this.audioBitrate = 48;
            this.audioChannels = 1;
        }

        public InjectStreamConfig(int width, int height, int videoGop, int videoFramerate, int videoBitrate, AUDIO_SAMPLE_RATE_TYPE audioSampleRate, int audioBitrate, int audioChannels)
        {
            this.width = width;
            this.height = height;
            this.videoGop = videoGop;
            this.videoFramerate = videoFramerate;
            this.videoBitrate = videoBitrate;
            this.audioSampleRate = audioSampleRate;
            this.audioBitrate = audioBitrate;
            this.audioChannels = audioChannels;
        }
    }

    ///
    /// <summary>
    /// Lifecycle of server-side transcoding stream.
    /// 
    /// Deprecated Deprecated
    /// </summary>
    ///
    public enum RTMP_STREAM_LIFE_CYCLE_TYPE
    {
        ///
        /// <summary>
        /// Bound to the channel lifecycle. That is, when all hosts leave the channel, the server-side transcoding stream stops after 30 seconds.
        /// </summary>
        ///
        RTMP_STREAM_LIFE_CYCLE_BIND2CHANNEL = 1,

        ///
        /// <summary>
        /// Bound to the lifecycle of the host who started the server-side transcoding stream. That is, when the host leaves, the server-side transcoding stream stops immediately.
        /// </summary>
        ///
        RTMP_STREAM_LIFE_CYCLE_BIND2OWNER = 2,

    }

    ///
    /// @ignore
    ///
    public class PublisherConfiguration
    {
        ///
        /// @ignore
        ///
        public int width;

        ///
        /// @ignore
        ///
        public int height;

        ///
        /// @ignore
        ///
        public int framerate;

        ///
        /// @ignore
        ///
        public int bitrate;

        ///
        /// @ignore
        ///
        public int defaultLayout;

        ///
        /// @ignore
        ///
        public int lifecycle;

        ///
        /// @ignore
        ///
        public bool owner;

        ///
        /// @ignore
        ///
        public int injectStreamWidth;

        ///
        /// @ignore
        ///
        public int injectStreamHeight;

        ///
        /// @ignore
        ///
        public string injectStreamUrl;

        ///
        /// @ignore
        ///
        public string publishUrl;

        ///
        /// @ignore
        ///
        public string rawStreamUrl;

        ///
        /// @ignore
        ///
        public string extraInfo;

        public PublisherConfiguration()
        {
            this.width = 640;
            this.height = 360;
            this.framerate = 15;
            this.bitrate = 500;
            this.defaultLayout = 1;
            this.lifecycle = (int)RTMP_STREAM_LIFE_CYCLE_TYPE.RTMP_STREAM_LIFE_CYCLE_BIND2CHANNEL;
            this.owner = true;
            this.injectStreamWidth = 0;
            this.injectStreamHeight = 0;
            this.injectStreamUrl = "";
            this.publishUrl = "";
            this.rawStreamUrl = "";
            this.extraInfo = "";
        }

        public PublisherConfiguration(int width, int height, int framerate, int bitrate, int defaultLayout, int lifecycle, bool owner, int injectStreamWidth, int injectStreamHeight, string injectStreamUrl, string publishUrl, string rawStreamUrl, string extraInfo)
        {
            this.width = width;
            this.height = height;
            this.framerate = framerate;
            this.bitrate = bitrate;
            this.defaultLayout = defaultLayout;
            this.lifecycle = lifecycle;
            this.owner = owner;
            this.injectStreamWidth = injectStreamWidth;
            this.injectStreamHeight = injectStreamHeight;
            this.injectStreamUrl = injectStreamUrl;
            this.publishUrl = publishUrl;
            this.rawStreamUrl = rawStreamUrl;
            this.extraInfo = extraInfo;
        }
    }

    ///
    /// <summary>
    /// Camera direction.
    /// </summary>
    ///
    public enum CAMERA_DIRECTION
    {
        ///
        /// <summary>
        /// 0: Rear camera.
        /// </summary>
        ///
        CAMERA_REAR = 0,

        ///
        /// <summary>
        /// 1: (Default) Front camera.
        /// </summary>
        ///
        CAMERA_FRONT = 1,

    }

    ///
    /// <summary>
    /// Cloud proxy type.
    /// </summary>
    ///
    public enum CLOUD_PROXY_TYPE
    {
        ///
        /// <summary>
        /// 0: Automatic mode. This is the default mode. In this mode, the SDK first connects to SD-RTN™. If it fails, it automatically switches to TLS 443.
        /// </summary>
        ///
        NONE_PROXY = 0,

        ///
        /// <summary>
        /// 1: UDP protocol cloud proxy, i.e., Force UDP mode. In this mode, the SDK always transmits data via UDP.
        /// </summary>
        ///
        UDP_PROXY = 1,

        ///
        /// <summary>
        /// 2: TCP (encrypted) protocol cloud proxy, i.e., Force TCP mode. In this mode, the SDK always transmits data via TLS 443.
        /// </summary>
        ///
        TCP_PROXY = 2,

    }

    ///
    /// <summary>
    /// Camera capture configuration.
    /// </summary>
    ///
    public class CameraCapturerConfiguration : IOptionalJsonParse
    {
        ///
        /// <summary>
        /// (Optional) Camera direction. See CAMERA_DIRECTION. This parameter applies to Android and iOS only.
        /// </summary>
        ///
        public Optional<CAMERA_DIRECTION> cameraDirection = new Optional<CAMERA_DIRECTION>();

        ///
        /// <summary>
        /// (Optional) Camera focal length type. See CAMERA_FOCAL_LENGTH_TYPE.
        ///  This parameter applies to Android and iOS only.
        ///  To set the camera focal length type, only cameraDirection is supported. cameraId is not supported.
        ///  Some iOS devices have composite rear cameras, such as dual (wide and ultra-wide) or triple (wide, ultra-wide, and telephoto) lenses. For such composite lenses with ultra-wide capabilities, you can achieve ultra-wide capture using either of the following methods:
        ///  Method 1: Set this parameter to CAMERA_FOCAL_LENGTH_ULTRA_WIDE (2) (ultra-wide lens).
        ///  Method 2: Set this parameter to CAMERA_FOCAL_LENGTH_DEFAULT (0) (standard lens), then call SetCameraZoomFactor to set the camera zoom factor to a value less than 1.0 (minimum 0.5). The difference is that Method 1 provides a fixed ultra-wide view, while Method 2 allows flexible zoom adjustment.
        /// </summary>
        ///
        public Optional<CAMERA_FOCAL_LENGTH_TYPE> cameraFocalLengthType = new Optional<CAMERA_FOCAL_LENGTH_TYPE>();

        ///
        /// <summary>
        /// (Optional) ID of the camera. This parameter applies to Windows and macOS only.
        /// </summary>
        ///
        public Optional<string> deviceId = new Optional<string>();

        ///
        /// <summary>
        /// (Optional) Camera ID. Defaults to the ID of the front-facing camera. You can obtain the camera ID via Android native system APIs. See [Camera.open()](https://developer.android.google.cn/reference/android/hardware/Camera#open(int)) and [CameraManager.getCameraIdList()](https://developer.android.google.cn/reference/android/hardware/camera2/CameraManager?hl=en#getCameraIdList).
        ///  This parameter applies to Android only.
        ///  This parameter and cameraDirection are both used to specify the camera and are mutually exclusive. You can choose either one as needed. The differences are as follows:
        ///  Using cameraDirection is simpler. You only need to specify the direction (front or rear), and the SDK will retrieve and determine the actual camera ID using system APIs.
        ///  Using cameraId allows you to precisely specify a particular camera. On multi-camera devices, cameraDirection may not be able to identify or access all available cameras. In such cases, it is recommended to use cameraId to directly specify the desired camera ID.
        /// </summary>
        ///
        public Optional<string> cameraId = new Optional<string>();

        ///
        /// <summary>
        /// (Optional) Whether to follow the video aspect ratio set in SetVideoEncoderConfiguration : true : (Default) Follow. The SDK crops the captured video to match the configured aspect ratio, and this affects local preview, OnCaptureVideoFrame, and OnPreEncodeVideoFrame. false : Do not follow. The SDK does not change the aspect ratio of the captured video frames.
        /// </summary>
        ///
        public Optional<bool> followEncodeDimensionRatio = new Optional<bool>();

        ///
        /// <summary>
        /// (Optional) Video frame format. See VideoFormat.
        /// </summary>
        ///
        public VideoFormat format;

        public CameraCapturerConfiguration()
        {
            this.format = new VideoFormat(0, 0, 0);
        }

        public CameraCapturerConfiguration(Optional<CAMERA_DIRECTION> cameraDirection, Optional<CAMERA_FOCAL_LENGTH_TYPE> cameraFocalLengthType, Optional<string> deviceId, Optional<string> cameraId, Optional<bool> followEncodeDimensionRatio, VideoFormat format)
        {
            this.cameraDirection = cameraDirection;
            this.cameraFocalLengthType = cameraFocalLengthType;
            this.deviceId = deviceId;
            this.cameraId = cameraId;
            this.followEncodeDimensionRatio = followEncodeDimensionRatio;
            this.format = format;
        }

        ///
        /// @ignore
        ///
        public virtual void ToJson(JsonWriter writer)
        {
            writer.WriteObjectStart();

            if (this.cameraDirection.HasValue())
            {
                writer.WritePropertyName("cameraDirection");
                AgoraJson.WriteEnum(writer, this.cameraDirection.GetValue());
            }

            if (this.cameraFocalLengthType.HasValue())
            {
                writer.WritePropertyName("cameraFocalLengthType");
                AgoraJson.WriteEnum(writer, this.cameraFocalLengthType.GetValue());
            }

            if (this.deviceId.HasValue())
            {
                writer.WritePropertyName("deviceId");
                writer.Write(this.deviceId.GetValue());
            }

            if (this.cameraId.HasValue())
            {
                writer.WritePropertyName("cameraId");
                writer.Write(this.cameraId.GetValue());
            }

            if (this.followEncodeDimensionRatio.HasValue())
            {
                writer.WritePropertyName("followEncodeDimensionRatio");
                writer.Write(this.followEncodeDimensionRatio.GetValue());
            }

            writer.WritePropertyName("format");
            JsonMapper.WriteValue(this.format, writer, false, 0);

            writer.WriteObjectEnd();
        }
    }

    ///
    /// <summary>
    /// Screen capture configuration.
    /// </summary>
    ///
    public class ScreenCaptureConfiguration
    {
        ///
        /// <summary>
        /// Whether to capture a window on the screen: true : Capture the window. false : (Default) Capture the screen, not the window.
        /// </summary>
        ///
        public bool isCaptureWindow;

        ///
        /// <summary>
        /// (macOS only) The display ID of the screen. Use this parameter only when capturing the screen on Mac devices.
        /// </summary>
        ///
        public long displayId;

        ///
        /// <summary>
        /// (Windows only) The position of the screen to be shared relative to the virtual screen. Use this parameter only when capturing the screen on Windows devices.
        /// </summary>
        ///
        public Rectangle screenRect;

        ///
        /// <summary>
        /// (Windows and macOS only) The window ID. Use this parameter only when capturing a window.
        /// </summary>
        ///
        public long windowId;

        public ScreenCaptureParameters @params;

        ///
        /// <summary>
        /// (Windows and macOS only) The position of the region to be shared relative to the entire screen. See Rectangle. If not set, the entire screen is shared. If the shared region exceeds the screen boundaries, only the content within the screen is shared. If the width or height in Rectangle is set to 0, the entire screen is shared.
        /// </summary>
        ///
        public Rectangle regionRect;

        public ScreenCaptureConfiguration()
        {
            this.isCaptureWindow = false;
            this.displayId = 0;
            this.windowId = 0;
        }

        public ScreenCaptureConfiguration(bool isCaptureWindow, long displayId, Rectangle screenRect, long windowId, ScreenCaptureParameters @params, Rectangle regionRect)
        {
            this.isCaptureWindow = isCaptureWindow;
            this.displayId = displayId;
            this.screenRect = screenRect;
            this.windowId = windowId;
            this.@params = @params;
            this.regionRect = regionRect;
        }
    }

    ///
    /// @ignore
    ///
    public class SIZE
    {
        ///
        /// @ignore
        ///
        public int width;

        ///
        /// @ignore
        ///
        public int height;

        public SIZE()
        {
            this.width = 0;
            this.height = 0;
        }

        public SIZE(int ww, int hh)
        {
            this.width = ww;
            this.height = hh;
        }

    }

    ///
    /// <summary>
    /// Image content of a thumbnail or icon. Set in ScreenCaptureSourceInfo.
    /// 
    /// The image is in ARGB format by default. If you need another format, please convert it manually.
    /// </summary>
    ///
    public class ThumbImageBuffer
    {
        ///
        /// <summary>
        /// The buffer of the thumbnail or icon.
        /// </summary>
        ///
        public byte[] buffer;

        ///
        /// <summary>
        /// The buffer length of the thumbnail or icon, in bytes.
        /// </summary>
        ///
        public uint length;

        ///
        /// <summary>
        /// The actual width (px) of the thumbnail or icon.
        /// </summary>
        ///
        public uint width;

        ///
        /// <summary>
        /// The actual height (px) of the thumbnail or icon.
        /// </summary>
        ///
        public uint height;

        public ThumbImageBuffer()
        {
            this.buffer = new byte[0];
            this.length = 0;
            this.width = 0;
            this.height = 0;
        }

        public ThumbImageBuffer(byte[] buffer, uint length, uint width, uint height)
        {
            this.buffer = buffer;
            this.length = length;
            this.width = width;
            this.height = height;
        }
    }

    ///
    /// <summary>
    /// The type of capture target. Set in ScreenCaptureSourceInfo.
    /// </summary>
    ///
    public enum ScreenCaptureSourceType
    {
        ///
        /// <summary>
        /// -1: Unknown.
        /// </summary>
        ///
        ScreenCaptureSourceType_Unknown = -1,

        ///
        /// <summary>
        /// 0: The capture target is a specific window.
        /// </summary>
        ///
        ScreenCaptureSourceType_Window = 0,

        ///
        /// <summary>
        /// 1: The capture target is the screen of a specific monitor.
        /// </summary>
        ///
        ScreenCaptureSourceType_Screen = 1,

        ///
        /// <summary>
        /// 2: Reserved parameter.
        /// </summary>
        ///
        ScreenCaptureSourceType_Custom = 2,

    }

    ///
    /// <summary>
    /// Information about shareable windows or screens.
    /// </summary>
    ///
    public class ScreenCaptureSourceInfo
    {
        ///
        /// <summary>
        /// Type of the sharing target. See ScreenCaptureSourceType.
        /// </summary>
        ///
        public ScreenCaptureSourceType type;

        ///
        /// <summary>
        /// For a window, this is the Window ID; for a screen, this is the Display ID.
        /// </summary>
        ///
        public long sourceId;

        ///
        /// <summary>
        /// Name of the window or screen. UTF-8 encoded.
        /// </summary>
        ///
        public string sourceName;

        ///
        /// <summary>
        /// Image content of the thumbnail. See ThumbImageBuffer.
        /// </summary>
        ///
        public ThumbImageBuffer thumbImage;

        ///
        /// <summary>
        /// Image content of the icon. See ThumbImageBuffer.
        /// </summary>
        ///
        public ThumbImageBuffer iconImage;

        ///
        /// <summary>
        /// Process to which the window belongs. UTF-8 encoded.
        /// </summary>
        ///
        public string processPath;

        ///
        /// <summary>
        /// Window title. UTF-8 encoded.
        /// </summary>
        ///
        public string sourceTitle;

        ///
        /// <summary>
        /// Whether the screen is the primary display: true : The screen is the primary display. false : The screen is not the primary display.
        /// </summary>
        ///
        public bool primaryMonitor;

        ///
        /// @ignore
        ///
        public bool isOccluded;

        ///
        /// <summary>
        /// Position of the window relative to the entire screen space (including all shareable screens). See Rectangle.
        /// </summary>
        ///
        public Rectangle position;

        ///
        /// @ignore
        ///
        public bool minimizeWindow;

        ///
        /// <summary>
        /// (Windows only) ID of the screen where the window is located. If the window spans multiple screens, this is the ID of the screen with the largest intersection area. If the window is outside the visible screen area, the value is -2.
        /// </summary>
        ///
        public long sourceDisplayId;

        public ScreenCaptureSourceInfo()
        {
            this.type = ScreenCaptureSourceType.ScreenCaptureSourceType_Unknown;
            this.sourceId = 0;
            this.sourceName = "";
            this.processPath = "";
            this.sourceTitle = "";
            this.primaryMonitor = false;
            this.isOccluded = false;
            this.minimizeWindow = false;
            this.sourceDisplayId = -2;
        }

        public ScreenCaptureSourceInfo(ScreenCaptureSourceType type, long sourceId, string sourceName, ThumbImageBuffer thumbImage, ThumbImageBuffer iconImage, string processPath, string sourceTitle, bool primaryMonitor, bool isOccluded, Rectangle position, bool minimizeWindow, long sourceDisplayId)
        {
            this.type = type;
            this.sourceId = sourceId;
            this.sourceName = sourceName;
            this.thumbImage = thumbImage;
            this.iconImage = iconImage;
            this.processPath = processPath;
            this.sourceTitle = sourceTitle;
            this.primaryMonitor = primaryMonitor;
            this.isOccluded = isOccluded;
            this.position = position;
            this.minimizeWindow = minimizeWindow;
            this.sourceDisplayId = sourceDisplayId;
        }
    }

    ///
    /// <summary>
    /// Advanced options for audio.
    /// </summary>
    ///
    public class AdvancedAudioOptions : IOptionalJsonParse
    {
        ///
        /// <summary>
        /// Number of channels for audio pre-processing. See AUDIO_PROCESSING_CHANNELS.
        /// </summary>
        ///
        public Optional<int> audioProcessingChannels = new Optional<int>();

        public AdvancedAudioOptions()
        {
        }

        public AdvancedAudioOptions(Optional<int> audioProcessingChannels)
        {
            this.audioProcessingChannels = audioProcessingChannels;
        }

        ///
        /// @ignore
        ///
        public virtual void ToJson(JsonWriter writer)
        {
            writer.WriteObjectStart();

            if (this.audioProcessingChannels.HasValue())
            {
                writer.WritePropertyName("audioProcessingChannels");
                writer.Write(this.audioProcessingChannels.GetValue());
            }

            writer.WriteObjectEnd();
        }
    }

    ///
    /// <summary>
    /// Settings options for placeholder images.
    /// </summary>
    ///
    public class ImageTrackOptions
    {
        ///
        /// <summary>
        /// The URL of the placeholder image. Currently supports JPEG, JPG, PNG, and GIF formats. You can add a placeholder image from a local absolute or relative path. On Android, adding placeholder images from /assets/ is not supported.
        /// </summary>
        ///
        public string imageUrl;

        ///
        /// <summary>
        /// Video frame rate, ranging from [1, 30]. The default value is 1.
        /// </summary>
        ///
        public int fps;

        ///
        /// @ignore
        ///
        public VIDEO_MIRROR_MODE_TYPE mirrorMode;

        public ImageTrackOptions()
        {
            this.imageUrl = "";
            this.fps = 1;
            this.mirrorMode = VIDEO_MIRROR_MODE_TYPE.VIDEO_MIRROR_MODE_DISABLED;
        }

        public ImageTrackOptions(string imageUrl, int fps, VIDEO_MIRROR_MODE_TYPE mirrorMode)
        {
            this.imageUrl = imageUrl;
            this.fps = fps;
            this.mirrorMode = mirrorMode;
        }
    }

    ///
    /// <summary>
    /// Channel media configuration options.
    /// 
    /// RtcConnection publishMicrophoneTrack publishCustomAudioTrack publishMediaPlayerAudioTrack true publishCameraTrack publishScreenCaptureVideo, publishScreenTrack, publishCustomVideoTrack publishEncodedVideoTrack true It is recommended that you set the member parameter values according to your business scenario. Otherwise, the SDK will assign values to the member parameters automatically.
    /// </summary>
    ///
    public class ChannelMediaOptions : IOptionalJsonParse
    {
        ///
        /// <summary>
        /// Sets whether to publish the video captured by the camera: true : Publishes the video captured by the camera. false : Does not publish the video captured by the camera.
        /// </summary>
        ///
        public Optional<bool> publishCameraTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the video captured by the second camera: true : Publishes the video captured by the second camera. false : Does not publish the video captured by the second camera.
        /// </summary>
        ///
        public Optional<bool> publishSecondaryCameraTrack = new Optional<bool>();

        ///
        /// <summary>
        /// This parameter is only applicable to Android, Windows, and macOS platforms. Sets whether to publish the video captured by the third camera: true : Publishes the video captured by the third camera. false : Does not publish the video captured by the third camera.
        /// </summary>
        ///
        public Optional<bool> publishThirdCameraTrack = new Optional<bool>();

        ///
        /// <summary>
        /// This parameter is only applicable to Android, Windows, and macOS platforms. Sets whether to publish the video captured by the fourth camera: true : Publishes the video captured by the fourth camera. false : Does not publish the video captured by the fourth camera.
        /// </summary>
        ///
        public Optional<bool> publishFourthCameraTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the audio captured by the microphone: true : Publishes the audio captured by the microphone. false : Does not publish the audio captured by the microphone.
        /// </summary>
        ///
        public Optional<bool> publishMicrophoneTrack = new Optional<bool>();

        ///
        /// <summary>
        /// This parameter is only applicable to Android and iOS platforms. Sets whether to publish the audio captured from the screen: true : Publishes the audio captured from the screen. false : Does not publish the audio captured from the screen.
        /// </summary>
        ///
        public Optional<bool> publishScreenCaptureAudio = new Optional<bool>();

        ///
        /// <summary>
        /// This parameter is only applicable to Android and iOS platforms. Sets whether to publish the video captured from the screen: true : Publishes the video captured from the screen. false : Does not publish the video captured from the screen.
        /// </summary>
        ///
        public Optional<bool> publishScreenCaptureVideo = new Optional<bool>();

        ///
        /// <summary>
        /// This parameter is only applicable to Windows and macOS platforms. Sets whether to publish the video captured from the screen: true : Publishes the video captured from the screen. false : Does not publish the video captured from the screen.
        /// </summary>
        ///
        public Optional<bool> publishScreenTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the video captured from the second screen: true : Publishes the video captured from the second screen. false : Does not publish the video captured from the second screen.
        /// </summary>
        ///
        public Optional<bool> publishSecondaryScreenTrack = new Optional<bool>();

        ///
        /// <summary>
        /// This parameter is only applicable to Windows and macOS platforms. Sets whether to publish the video captured from the third screen: true : Publishes the video captured from the third screen. false : Does not publish the video captured from the third screen.
        /// </summary>
        ///
        public Optional<bool> publishThirdScreenTrack = new Optional<bool>();

        ///
        /// <summary>
        /// This parameter is only applicable to Windows and macOS platforms. Sets whether to publish the video captured from the fourth screen: true : Publishes the video captured from the fourth screen. false : Does not publish the video captured from the fourth screen.
        /// </summary>
        ///
        public Optional<bool> publishFourthScreenTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the custom captured audio: true : Publishes the custom captured audio. false : Does not publish the custom captured audio.
        /// </summary>
        ///
        public Optional<bool> publishCustomAudioTrack = new Optional<bool>();

        ///
        /// <summary>
        /// ID of the custom audio track to be published. The default value is 0. You can get the custom audio track ID through the CreateCustomAudioTrack method.
        /// </summary>
        ///
        public Optional<int> publishCustomAudioTrackId = new Optional<int>();

        ///
        /// <summary>
        /// Sets whether to publish the custom captured video: true : Publishes the custom captured video. false : Does not publish the custom captured video.
        /// </summary>
        ///
        public Optional<bool> publishCustomVideoTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the encoded video: true : Publishes the encoded video. false : Does not publish the encoded video.
        /// </summary>
        ///
        public Optional<bool> publishEncodedVideoTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the audio from the media player: true : Publishes the audio from the media player. false : Does not publish the audio from the media player.
        /// </summary>
        ///
        public Optional<bool> publishMediaPlayerAudioTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the video from the media player: true : Publishes the video from the media player. false : Does not publish the video from the media player.
        /// </summary>
        ///
        public Optional<bool> publishMediaPlayerVideoTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the local transcoded video: true : Publishes the local transcoded video. false : Does not publish the local transcoded video.
        /// </summary>
        ///
        public Optional<bool> publishTranscodedVideoTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the local audio mixing: true : Publishes the local audio mixing. false : Does not publish the local audio mixing.
        /// </summary>
        ///
        public Optional<bool> publishMixedAudioTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the video processed by the voice-driven plugin: true : Publishes the video processed by the voice-driven plugin. false : (default) Does not publish the video processed by the voice-driven plugin.
        /// </summary>
        ///
        public Optional<bool> publishLipSyncTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to automatically subscribe to all audio streams: true : Automatically subscribes to all audio streams. false : Does not automatically subscribe to any audio stream.
        /// </summary>
        ///
        public Optional<bool> autoSubscribeAudio = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to automatically subscribe to all video streams: true : Automatically subscribes to all video streams. false : Does not automatically subscribe to any video stream.
        /// </summary>
        ///
        public Optional<bool> autoSubscribeVideo = new Optional<bool>();

        ///
        /// <summary>
        /// If you need to publish the audio stream captured by the microphone, make sure this parameter is set to true. Sets whether to enable audio recording or playback: true : Enables audio recording or playback. false : Disables audio recording or playback.
        /// </summary>
        ///
        public Optional<bool> enableAudioRecordingOrPlayout = new Optional<bool>();

        ///
        /// <summary>
        /// ID of the media player to be published. The default value is 0.
        /// </summary>
        ///
        public Optional<int> publishMediaPlayerId = new Optional<int>();

        ///
        /// <summary>
        /// User role. See CLIENT_ROLE_TYPE. Users with the audience role cannot publish audio or video streams in the channel. When publishing streams in a live broadcast scenario, make sure the user role is set to broadcaster.
        /// </summary>
        ///
        public Optional<CLIENT_ROLE_TYPE> clientRoleType = new Optional<CLIENT_ROLE_TYPE>();

        ///
        /// <summary>
        /// Audience latency level. See AUDIENCE_LATENCY_LEVEL_TYPE.
        /// </summary>
        ///
        public Optional<AUDIENCE_LATENCY_LEVEL_TYPE> audienceLatencyLevel = new Optional<AUDIENCE_LATENCY_LEVEL_TYPE>();

        ///
        /// <summary>
        /// Default video stream type to subscribe to: VIDEO_STREAM_TYPE.
        /// </summary>
        ///
        public Optional<VIDEO_STREAM_TYPE> defaultVideoStreamType = new Optional<VIDEO_STREAM_TYPE>();

        ///
        /// <summary>
        /// Channel usage scenario. See CHANNEL_PROFILE_TYPE.
        /// </summary>
        ///
        public Optional<CHANNEL_PROFILE_TYPE> channelProfile = new Optional<CHANNEL_PROFILE_TYPE>();

        ///
        /// <summary>
        /// Delay (in milliseconds) for sending audio frames. You can use this parameter to set the delay for sending audio frames to ensure audio-video synchronization.
        /// To disable the delay, set this parameter to 0.
        /// </summary>
        ///
        public Optional<int> audioDelayMs = new Optional<int>();

        ///
        /// @ignore
        ///
        public Optional<int> mediaPlayerAudioDelayMs = new Optional<int>();

        ///
        /// <summary>
        /// (Optional) A dynamic key generated on the server for authentication. See [Use Token for Authentication](https://doc.shengwang.cn/doc/rtc/unity/basic-features/token-authentication).
        ///  This parameter takes effect only when calling UpdateChannelMediaOptions or UpdateChannelMediaOptionsEx.
        ///  Make sure the App ID, channel name, and user name used to generate the token are the same as those used in the Initialize method to initialize the engine, and the channel name and user name used in JoinChannel [2/2] or JoinChannelEx to join the channel.
        /// </summary>
        ///
        public Optional<string> token = new Optional<string>();

        ///
        /// @ignore
        ///
        public Optional<bool> enableBuiltInMediaEncryption = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the virtual metronome sound to remote users: true : Publishes. Both local and remote users can hear the metronome. false : Does not publish. Only the local user can hear the metronome.
        /// </summary>
        ///
        public Optional<bool> publishRhythmPlayerTrack = new Optional<bool>();

        ///
        /// <summary>
        /// This parameter is used to implement cross-room co-hosting scenarios. The co-host needs to call the JoinChannelEx method to join the other live room as an audience and set isInteractiveAudience to true.
        ///  This parameter takes effect only when the user role is CLIENT_ROLE_AUDIENCE. Whether to enable interactive audience mode: true : Enables interactive audience mode. After successfully enabling, the local user, as an interactive audience, receives low-latency and smooth video from remote users. false : Disables interactive audience mode. The local user, as a regular audience, receives remote user video with default settings.
        /// </summary>
        ///
        public Optional<bool> isInteractiveAudience = new Optional<bool>();

        ///
        /// <summary>
        /// Video track ID returned by the CreateCustomVideoTrack method. The default value is 0.
        /// </summary>
        ///
        public Optional<uint> customVideoTrackId = new Optional<uint>();

        ///
        /// <summary>
        /// To enable this feature, please [contact sales](https://www.shengwang.cn/contact-sales/). Sets whether the current audio stream participates in stream selection based on volume level algorithm. true : Participates in volume-based stream selection. If volume-based stream selection is not enabled, this parameter has no effect. false : Does not participate in volume-based stream selection.
        /// </summary>
        ///
        public Optional<bool> isAudioFilterable = new Optional<bool>();

        ///
        /// @ignore
        ///
        public Optional<string> parameters = new Optional<string>();

        ///
        /// <summary>
        /// Permissions and system requirements:
        ///  Android: Android 7.0 or later (API level 24 or above), requires ACCESS_NETWORK_STATE and CHANGE_NETWORK_STATE permissions.
        ///  iOS: iOS 12.0 or later.
        ///  macOS: 10.14 or later.
        ///  Windows: Windows Vista or later. Whether to enable multipath transmission: true : Enables multipath transmission. false : Disables multipath transmission.
        /// </summary>
        ///
        public Optional<bool> enableMultipath = new Optional<bool>();

        ///
        /// <summary>
        /// Uplink transmission mode. See MultipathMode. When using this parameter, make sure enableMultipath is set to true.
        /// </summary>
        ///
        public Optional<MultipathMode> uplinkMultipathMode = new Optional<MultipathMode>();

        ///
        /// <summary>
        /// Downlink transmission mode. See MultipathMode. When using this parameter, make sure enableMultipath is set to true.
        /// </summary>
        ///
        public Optional<MultipathMode> downlinkMultipathMode = new Optional<MultipathMode>();

        ///
        /// <summary>
        /// Preferred transmission path type. See MultipathType. When using this parameter, make sure enableMultipath is set to true.
        /// </summary>
        ///
        public Optional<MultipathType> preferMultipathType = new Optional<MultipathType>();

        public ChannelMediaOptions()
        {
        }

        public ChannelMediaOptions(Optional<bool> publishCameraTrack, Optional<bool> publishSecondaryCameraTrack, Optional<bool> publishThirdCameraTrack, Optional<bool> publishFourthCameraTrack, Optional<bool> publishMicrophoneTrack, Optional<bool> publishScreenCaptureAudio, Optional<bool> publishScreenCaptureVideo, Optional<bool> publishScreenTrack, Optional<bool> publishSecondaryScreenTrack, Optional<bool> publishThirdScreenTrack, Optional<bool> publishFourthScreenTrack, Optional<bool> publishCustomAudioTrack, Optional<int> publishCustomAudioTrackId, Optional<bool> publishCustomVideoTrack, Optional<bool> publishEncodedVideoTrack, Optional<bool> publishMediaPlayerAudioTrack, Optional<bool> publishMediaPlayerVideoTrack, Optional<bool> publishTranscodedVideoTrack, Optional<bool> publishMixedAudioTrack, Optional<bool> publishLipSyncTrack, Optional<bool> autoSubscribeAudio, Optional<bool> autoSubscribeVideo, Optional<bool> enableAudioRecordingOrPlayout, Optional<int> publishMediaPlayerId, Optional<CLIENT_ROLE_TYPE> clientRoleType, Optional<AUDIENCE_LATENCY_LEVEL_TYPE> audienceLatencyLevel, Optional<VIDEO_STREAM_TYPE> defaultVideoStreamType, Optional<CHANNEL_PROFILE_TYPE> channelProfile, Optional<int> audioDelayMs, Optional<int> mediaPlayerAudioDelayMs, Optional<string> token, Optional<bool> enableBuiltInMediaEncryption, Optional<bool> publishRhythmPlayerTrack, Optional<bool> isInteractiveAudience, Optional<uint> customVideoTrackId, Optional<bool> isAudioFilterable, Optional<string> parameters, Optional<bool> enableMultipath, Optional<MultipathMode> uplinkMultipathMode, Optional<MultipathMode> downlinkMultipathMode, Optional<MultipathType> preferMultipathType)
        {
            this.publishCameraTrack = publishCameraTrack;
            this.publishSecondaryCameraTrack = publishSecondaryCameraTrack;
            this.publishThirdCameraTrack = publishThirdCameraTrack;
            this.publishFourthCameraTrack = publishFourthCameraTrack;
            this.publishMicrophoneTrack = publishMicrophoneTrack;
            this.publishScreenCaptureAudio = publishScreenCaptureAudio;
            this.publishScreenCaptureVideo = publishScreenCaptureVideo;
            this.publishScreenTrack = publishScreenTrack;
            this.publishSecondaryScreenTrack = publishSecondaryScreenTrack;
            this.publishThirdScreenTrack = publishThirdScreenTrack;
            this.publishFourthScreenTrack = publishFourthScreenTrack;
            this.publishCustomAudioTrack = publishCustomAudioTrack;
            this.publishCustomAudioTrackId = publishCustomAudioTrackId;
            this.publishCustomVideoTrack = publishCustomVideoTrack;
            this.publishEncodedVideoTrack = publishEncodedVideoTrack;
            this.publishMediaPlayerAudioTrack = publishMediaPlayerAudioTrack;
            this.publishMediaPlayerVideoTrack = publishMediaPlayerVideoTrack;
            this.publishTranscodedVideoTrack = publishTranscodedVideoTrack;
            this.publishMixedAudioTrack = publishMixedAudioTrack;
            this.publishLipSyncTrack = publishLipSyncTrack;
            this.autoSubscribeAudio = autoSubscribeAudio;
            this.autoSubscribeVideo = autoSubscribeVideo;
            this.enableAudioRecordingOrPlayout = enableAudioRecordingOrPlayout;
            this.publishMediaPlayerId = publishMediaPlayerId;
            this.clientRoleType = clientRoleType;
            this.audienceLatencyLevel = audienceLatencyLevel;
            this.defaultVideoStreamType = defaultVideoStreamType;
            this.channelProfile = channelProfile;
            this.audioDelayMs = audioDelayMs;
            this.mediaPlayerAudioDelayMs = mediaPlayerAudioDelayMs;
            this.token = token;
            this.enableBuiltInMediaEncryption = enableBuiltInMediaEncryption;
            this.publishRhythmPlayerTrack = publishRhythmPlayerTrack;
            this.isInteractiveAudience = isInteractiveAudience;
            this.customVideoTrackId = customVideoTrackId;
            this.isAudioFilterable = isAudioFilterable;
            this.parameters = parameters;
            this.enableMultipath = enableMultipath;
            this.uplinkMultipathMode = uplinkMultipathMode;
            this.downlinkMultipathMode = downlinkMultipathMode;
            this.preferMultipathType = preferMultipathType;
        }

        ///
        /// @ignore
        ///
        public virtual void ToJson(JsonWriter writer)
        {
            writer.WriteObjectStart();

            if (this.publishCameraTrack.HasValue())
            {
                writer.WritePropertyName("publishCameraTrack");
                writer.Write(this.publishCameraTrack.GetValue());
            }

            if (this.publishSecondaryCameraTrack.HasValue())
            {
                writer.WritePropertyName("publishSecondaryCameraTrack");
                writer.Write(this.publishSecondaryCameraTrack.GetValue());
            }

            if (this.publishThirdCameraTrack.HasValue())
            {
                writer.WritePropertyName("publishThirdCameraTrack");
                writer.Write(this.publishThirdCameraTrack.GetValue());
            }

            if (this.publishFourthCameraTrack.HasValue())
            {
                writer.WritePropertyName("publishFourthCameraTrack");
                writer.Write(this.publishFourthCameraTrack.GetValue());
            }

            if (this.publishMicrophoneTrack.HasValue())
            {
                writer.WritePropertyName("publishMicrophoneTrack");
                writer.Write(this.publishMicrophoneTrack.GetValue());
            }

            if (this.publishScreenCaptureAudio.HasValue())
            {
                writer.WritePropertyName("publishScreenCaptureAudio");
                writer.Write(this.publishScreenCaptureAudio.GetValue());
            }

            if (this.publishScreenCaptureVideo.HasValue())
            {
                writer.WritePropertyName("publishScreenCaptureVideo");
                writer.Write(this.publishScreenCaptureVideo.GetValue());
            }

            if (this.publishScreenTrack.HasValue())
            {
                writer.WritePropertyName("publishScreenTrack");
                writer.Write(this.publishScreenTrack.GetValue());
            }

            if (this.publishSecondaryScreenTrack.HasValue())
            {
                writer.WritePropertyName("publishSecondaryScreenTrack");
                writer.Write(this.publishSecondaryScreenTrack.GetValue());
            }

            if (this.publishThirdScreenTrack.HasValue())
            {
                writer.WritePropertyName("publishThirdScreenTrack");
                writer.Write(this.publishThirdScreenTrack.GetValue());
            }

            if (this.publishFourthScreenTrack.HasValue())
            {
                writer.WritePropertyName("publishFourthScreenTrack");
                writer.Write(this.publishFourthScreenTrack.GetValue());
            }

            if (this.publishCustomAudioTrack.HasValue())
            {
                writer.WritePropertyName("publishCustomAudioTrack");
                writer.Write(this.publishCustomAudioTrack.GetValue());
            }

            if (this.publishCustomAudioTrackId.HasValue())
            {
                writer.WritePropertyName("publishCustomAudioTrackId");
                writer.Write(this.publishCustomAudioTrackId.GetValue());
            }

            if (this.publishCustomVideoTrack.HasValue())
            {
                writer.WritePropertyName("publishCustomVideoTrack");
                writer.Write(this.publishCustomVideoTrack.GetValue());
            }

            if (this.publishEncodedVideoTrack.HasValue())
            {
                writer.WritePropertyName("publishEncodedVideoTrack");
                writer.Write(this.publishEncodedVideoTrack.GetValue());
            }

            if (this.publishMediaPlayerAudioTrack.HasValue())
            {
                writer.WritePropertyName("publishMediaPlayerAudioTrack");
                writer.Write(this.publishMediaPlayerAudioTrack.GetValue());
            }

            if (this.publishMediaPlayerVideoTrack.HasValue())
            {
                writer.WritePropertyName("publishMediaPlayerVideoTrack");
                writer.Write(this.publishMediaPlayerVideoTrack.GetValue());
            }

            if (this.publishTranscodedVideoTrack.HasValue())
            {
                writer.WritePropertyName("publishTranscodedVideoTrack");
                writer.Write(this.publishTranscodedVideoTrack.GetValue());
            }

            if (this.publishMixedAudioTrack.HasValue())
            {
                writer.WritePropertyName("publishMixedAudioTrack");
                writer.Write(this.publishMixedAudioTrack.GetValue());
            }

            if (this.publishLipSyncTrack.HasValue())
            {
                writer.WritePropertyName("publishLipSyncTrack");
                writer.Write(this.publishLipSyncTrack.GetValue());
            }

            if (this.autoSubscribeAudio.HasValue())
            {
                writer.WritePropertyName("autoSubscribeAudio");
                writer.Write(this.autoSubscribeAudio.GetValue());
            }

            if (this.autoSubscribeVideo.HasValue())
            {
                writer.WritePropertyName("autoSubscribeVideo");
                writer.Write(this.autoSubscribeVideo.GetValue());
            }

            if (this.enableAudioRecordingOrPlayout.HasValue())
            {
                writer.WritePropertyName("enableAudioRecordingOrPlayout");
                writer.Write(this.enableAudioRecordingOrPlayout.GetValue());
            }

            if (this.publishMediaPlayerId.HasValue())
            {
                writer.WritePropertyName("publishMediaPlayerId");
                writer.Write(this.publishMediaPlayerId.GetValue());
            }

            if (this.clientRoleType.HasValue())
            {
                writer.WritePropertyName("clientRoleType");
                AgoraJson.WriteEnum(writer, this.clientRoleType.GetValue());
            }

            if (this.audienceLatencyLevel.HasValue())
            {
                writer.WritePropertyName("audienceLatencyLevel");
                AgoraJson.WriteEnum(writer, this.audienceLatencyLevel.GetValue());
            }

            if (this.defaultVideoStreamType.HasValue())
            {
                writer.WritePropertyName("defaultVideoStreamType");
                AgoraJson.WriteEnum(writer, this.defaultVideoStreamType.GetValue());
            }

            if (this.channelProfile.HasValue())
            {
                writer.WritePropertyName("channelProfile");
                AgoraJson.WriteEnum(writer, this.channelProfile.GetValue());
            }

            if (this.audioDelayMs.HasValue())
            {
                writer.WritePropertyName("audioDelayMs");
                writer.Write(this.audioDelayMs.GetValue());
            }

            if (this.mediaPlayerAudioDelayMs.HasValue())
            {
                writer.WritePropertyName("mediaPlayerAudioDelayMs");
                writer.Write(this.mediaPlayerAudioDelayMs.GetValue());
            }

            if (this.token.HasValue())
            {
                writer.WritePropertyName("token");
                writer.Write(this.token.GetValue());
            }

            if (this.enableBuiltInMediaEncryption.HasValue())
            {
                writer.WritePropertyName("enableBuiltInMediaEncryption");
                writer.Write(this.enableBuiltInMediaEncryption.GetValue());
            }

            if (this.publishRhythmPlayerTrack.HasValue())
            {
                writer.WritePropertyName("publishRhythmPlayerTrack");
                writer.Write(this.publishRhythmPlayerTrack.GetValue());
            }

            if (this.isInteractiveAudience.HasValue())
            {
                writer.WritePropertyName("isInteractiveAudience");
                writer.Write(this.isInteractiveAudience.GetValue());
            }

            if (this.customVideoTrackId.HasValue())
            {
                writer.WritePropertyName("customVideoTrackId");
                writer.Write(this.customVideoTrackId.GetValue());
            }

            if (this.isAudioFilterable.HasValue())
            {
                writer.WritePropertyName("isAudioFilterable");
                writer.Write(this.isAudioFilterable.GetValue());
            }

            if (this.parameters.HasValue())
            {
                writer.WritePropertyName("parameters");
                writer.Write(this.parameters.GetValue());
            }

            if (this.enableMultipath.HasValue())
            {
                writer.WritePropertyName("enableMultipath");
                writer.Write(this.enableMultipath.GetValue());
            }

            if (this.uplinkMultipathMode.HasValue())
            {
                writer.WritePropertyName("uplinkMultipathMode");
                AgoraJson.WriteEnum(writer, this.uplinkMultipathMode.GetValue());
            }

            if (this.downlinkMultipathMode.HasValue())
            {
                writer.WritePropertyName("downlinkMultipathMode");
                AgoraJson.WriteEnum(writer, this.downlinkMultipathMode.GetValue());
            }

            if (this.preferMultipathType.HasValue())
            {
                writer.WritePropertyName("preferMultipathType");
                AgoraJson.WriteEnum(writer, this.preferMultipathType.GetValue());
            }

            writer.WriteObjectEnd();
        }
    }

    ///
    /// <summary>
    /// Proxy types.
    /// </summary>
    ///
    public enum PROXY_TYPE
    {
        ///
        /// <summary>
        /// 0: Reserved parameter, not supported yet.
        /// </summary>
        ///
        NONE_PROXY_TYPE = 0,

        ///
        /// <summary>
        /// 1: Cloud proxy using UDP protocol, i.e., Force UDP cloud proxy mode. In this mode, the SDK always transmits data via UDP.
        /// </summary>
        ///
        UDP_PROXY_TYPE = 1,

        ///
        /// <summary>
        /// 2: Cloud proxy using TCP (encrypted) protocol, i.e., Force TCP cloud proxy mode. In this mode, the SDK always transmits data via TLS 443.
        /// </summary>
        ///
        TCP_PROXY_TYPE = 2,

        ///
        /// <summary>
        /// 3: Reserved parameter, not supported yet.
        /// </summary>
        ///
        LOCAL_PROXY_TYPE = 3,

        ///
        /// <summary>
        /// 4: Auto mode. In this mode, the SDK first attempts to connect to SD-RTN™. If it fails, it automatically switches to TLS 443.
        /// </summary>
        ///
        TCP_PROXY_AUTO_FALLBACK_TYPE = 4,

        ///
        /// @ignore
        ///
        HTTP_PROXY_TYPE = 5,

        ///
        /// @ignore
        ///
        HTTPS_PROXY_TYPE = 6,

    }

    ///
    /// <summary>
    /// Advanced feature types.
    /// </summary>
    ///
    public enum FeatureType
    {
        ///
        /// <summary>
        /// 1: Virtual background feature.
        /// </summary>
        ///
        VIDEO_VIRTUAL_BACKGROUND = 1,

        ///
        /// <summary>
        /// 2: Beauty effect feature.
        /// </summary>
        ///
        VIDEO_BEAUTY_EFFECT = 2,

    }

    ///
    /// <summary>
    /// Options for leaving a channel.
    /// </summary>
    ///
    public class LeaveChannelOptions
    {
        ///
        /// <summary>
        /// Whether to stop playing music files and audio mixing when leaving the channel: true : (Default) Stop playing music files and audio mixing. false : Do not stop playing music files and audio mixing.
        /// </summary>
        ///
        public bool stopAudioMixing;

        ///
        /// <summary>
        /// Whether to stop playing sound effects when leaving the channel: true : (Default) Stop playing sound effects. false : Do not stop playing sound effects.
        /// </summary>
        ///
        public bool stopAllEffect;

        ///
        /// <summary>
        /// Whether to stop microphone capture when leaving the channel: true : (Default) Stop microphone capture. false : Do not stop microphone capture.
        /// </summary>
        ///
        public bool stopMicrophoneRecording;

        public LeaveChannelOptions()
        {
            this.stopAudioMixing = true;
            this.stopAllEffect = true;
            this.stopMicrophoneRecording = true;
        }

        public LeaveChannelOptions(bool stopAudioMixing, bool stopAllEffect, bool stopMicrophoneRecording)
        {
            this.stopAudioMixing = stopAudioMixing;
            this.stopAllEffect = stopAllEffect;
            this.stopMicrophoneRecording = stopMicrophoneRecording;
        }
    }

    ///
    /// <summary>
    /// Video effect node types.
    /// 
    /// Since Available since v4.6.2.
    /// </summary>
    ///
    public enum VIDEO_EFFECT_NODE_ID : uint
    {
        ///
        /// <summary>
        /// (1): Beauty effect node.
        /// </summary>
        ///
        BEAUTY = 1U << 0,

        ///
        /// <summary>
        /// (2): Style makeup effect node.
        /// </summary>
        ///
        STYLE_MAKEUP = 1U << 1,

        ///
        /// <summary>
        /// (4): Filter effect node.
        /// </summary>
        ///
        FILTER = 1U << 2,

    }

    ///
    /// <summary>
    /// Operation types performed on video effect nodes.
    /// 
    /// Since Available since v4.6.2.
    /// </summary>
    ///
    public enum VIDEO_EFFECT_ACTION
    {
        ///
        /// <summary>
        /// (1): Save the current parameters of the video effect.
        /// </summary>
        ///
        SAVE = 1,

        ///
        /// <summary>
        /// (2): Reset the video effect to default parameters.
        /// </summary>
        ///
        RESET = 2,

    }

    ///
    /// @ignore
    ///
    public class RtcEngineContext : IOptionalJsonParse
    {
        ///
        /// @ignore
        ///
        public string appId;

        ///
        /// @ignore
        ///
        public ulong context;

        ///
        /// @ignore
        ///
        public CHANNEL_PROFILE_TYPE channelProfile;

        ///
        /// @ignore
        ///
        public string license;

        ///
        /// @ignore
        ///
        public AUDIO_SCENARIO_TYPE audioScenario;

        ///
        /// @ignore
        ///
        public AREA_CODE areaCode;

        ///
        /// @ignore
        ///
        public LogConfig logConfig;

        ///
        /// @ignore
        ///
        public Optional<THREAD_PRIORITY_TYPE> threadPriority = new Optional<THREAD_PRIORITY_TYPE>();

        ///
        /// @ignore
        ///
        public bool useExternalEglContext;

        ///
        /// @ignore
        ///
        public bool domainLimit;

        ///
        /// @ignore
        ///
        public bool autoRegisterAgoraExtensions;

        public RtcEngineContext()
        {
            this.appId = "";
            this.context = 0;
            this.channelProfile = CHANNEL_PROFILE_TYPE.CHANNEL_PROFILE_LIVE_BROADCASTING;
            this.license = "";
            this.audioScenario = AUDIO_SCENARIO_TYPE.AUDIO_SCENARIO_DEFAULT;
            this.areaCode = AREA_CODE.AREA_CODE_GLOB;
            this.logConfig = new LogConfig();
            this.useExternalEglContext = false;
            this.domainLimit = false;
            this.autoRegisterAgoraExtensions = true;
        }

        public RtcEngineContext(string appId, ulong context, CHANNEL_PROFILE_TYPE channelProfile, string license, AUDIO_SCENARIO_TYPE audioScenario, AREA_CODE areaCode, LogConfig logConfig, Optional<THREAD_PRIORITY_TYPE> threadPriority, bool useExternalEglContext, bool domainLimit, bool autoRegisterAgoraExtensions)
        {
            this.appId = appId;
            this.context = context;
            this.channelProfile = channelProfile;
            this.license = license;
            this.audioScenario = audioScenario;
            this.areaCode = areaCode;
            this.logConfig = logConfig;
            this.threadPriority = threadPriority;
            this.useExternalEglContext = useExternalEglContext;
            this.domainLimit = domainLimit;
            this.autoRegisterAgoraExtensions = autoRegisterAgoraExtensions;
        }

        ///
        /// @ignore
        ///
        public virtual void ToJson(JsonWriter writer)
        {
            writer.WriteObjectStart();

            writer.WritePropertyName("appId");
            writer.Write(this.appId);

            writer.WritePropertyName("context");
            writer.Write(this.context);

            writer.WritePropertyName("channelProfile");
            AgoraJson.WriteEnum(writer, this.channelProfile);

            writer.WritePropertyName("license");
            writer.Write(this.license);

            writer.WritePropertyName("audioScenario");
            AgoraJson.WriteEnum(writer, this.audioScenario);

            writer.WritePropertyName("areaCode");
            AgoraJson.WriteEnum(writer, this.areaCode);

            writer.WritePropertyName("logConfig");
            JsonMapper.WriteValue(this.logConfig, writer, false, 0);

            if (this.threadPriority.HasValue())
            {
                writer.WritePropertyName("threadPriority");
                AgoraJson.WriteEnum(writer, this.threadPriority.GetValue());
            }

            writer.WritePropertyName("useExternalEglContext");
            writer.Write(this.useExternalEglContext);

            writer.WritePropertyName("domainLimit");
            writer.Write(this.domainLimit);

            writer.WritePropertyName("autoRegisterAgoraExtensions");
            writer.Write(this.autoRegisterAgoraExtensions);

            writer.WriteObjectEnd();
        }
    }

    ///
    /// <summary>
    /// Metadata type for the observer. Currently only supports video metadata.
    /// </summary>
    ///
    public enum METADATA_TYPE
    {
        ///
        /// <summary>
        /// -1: Unknown metadata type.
        /// </summary>
        ///
        UNKNOWN_METADATA = -1,

        ///
        /// <summary>
        /// 0: Metadata type is video.
        /// </summary>
        ///
        VIDEO_METADATA = 0,

    }

    ///
    /// @ignore
    ///
    public enum MAX_METADATA_SIZE_TYPE
    {
        ///
        /// @ignore
        ///
        INVALID_METADATA_SIZE_IN_BYTE = -1,

        ///
        /// @ignore
        ///
        DEFAULT_METADATA_SIZE_IN_BYTE = 512,

        ///
        /// @ignore
        ///
        MAX_METADATA_SIZE_IN_BYTE = 1024,

    }

    ///
    /// <summary>
    /// Media metadata.
    /// </summary>
    ///
    public class Metadata
    {
        ///
        /// <summary>
        /// Channel name.
        /// </summary>
        ///
        public string channelId;

        ///
        /// <summary>
        /// User ID.
        ///  For receiver: ID of the remote user who sent this Metadata.
        ///  For sender: Ignore this.
        /// </summary>
        ///
        public uint uid;

        ///
        /// <summary>
        /// Buffer size of the received or sent Metadata.
        /// </summary>
        ///
        public uint size;

        ///
        /// <summary>
        /// Buffer address of the received Metadata.
        /// </summary>
        ///
        public IntPtr buffer;

        ///
        /// <summary>
        /// Timestamp when the Metadata is sent, in milliseconds.
        /// </summary>
        ///
        public long timeStampMs;

        public Metadata()
        {
            this.channelId = "";
            this.uid = 0;
            this.size = 0;
            this.buffer = IntPtr.Zero;
            this.timeStampMs = 0;
        }

        public Metadata(string channelId, uint uid, uint size, IntPtr buffer, long timeStampMs)
        {
            this.channelId = channelId;
            this.uid = uid;
            this.size = size;
            this.buffer = buffer;
            this.timeStampMs = timeStampMs;
        }
    }

    ///
    /// <summary>
    /// Reason for change in CDN streaming status.
    /// 
    /// Deprecated Deprecated since v4.6.2.
    /// </summary>
    ///
    public enum DIRECT_CDN_STREAMING_REASON
    {
        ///
        /// <summary>
        /// 0: Streaming status is normal.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_REASON_OK = 0,

        ///
        /// <summary>
        /// 1: General error with no specific reason. You may try restarting the stream.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_REASON_FAILED = 1,

        ///
        /// <summary>
        /// 2: Audio streaming error. For example, local audio capture device not working properly, occupied by another process, or lacking permission.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_REASON_AUDIO_PUBLICATION = 2,

        ///
        /// <summary>
        /// 3: Video streaming error. For example, local video capture device not working properly, occupied by another process, or lacking permission.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_REASON_VIDEO_PUBLICATION = 3,

        ///
        /// <summary>
        /// 4: Failed to connect to CDN.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_REASON_NET_CONNECT = 4,

        ///
        /// <summary>
        /// 5: The URL has already been used for streaming. Please use a new URL.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_REASON_BAD_NAME = 5,

    }

    ///
    /// <summary>
    /// Current CDN streaming state.
    /// 
    /// Deprecated Deprecated since v4.6.2.
    /// </summary>
    ///
    public enum DIRECT_CDN_STREAMING_STATE
    {
        ///
        /// <summary>
        /// 0: Initial state, streaming has not started yet.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_STATE_IDLE = 0,

        ///
        /// <summary>
        /// 1: Streaming in progress. When you call StartDirectCdnStreaming and streaming starts successfully, the SDK returns this value.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_STATE_RUNNING = 1,

        ///
        /// <summary>
        /// 2: Streaming has ended normally. When you call StopDirectCdnStreaming to stop streaming manually, the SDK returns this value.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_STATE_STOPPED = 2,

        ///
        /// <summary>
        /// 3: Streaming failed. You can troubleshoot using the information reported by the OnDirectCdnStreamingStateChanged callback and then restart streaming.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_STATE_FAILED = 3,

        ///
        /// <summary>
        /// 4: Attempting to reconnect to the Agora server and CDN. It retries up to 10 times. If reconnection still fails, the streaming state changes to DIRECT_CDN_STREAMING_STATE_FAILED.
        /// </summary>
        ///
        DIRECT_CDN_STREAMING_STATE_RECOVERING = 4,

    }

    ///
    /// <summary>
    /// Current CDN streaming statistics.
    /// 
    /// Deprecated Deprecated since v4.6.2.
    /// </summary>
    ///
    public class DirectCdnStreamingStats
    {
        ///
        /// <summary>
        /// Video width (px).
        /// </summary>
        ///
        public int videoWidth;

        ///
        /// <summary>
        /// Video height (px).
        /// </summary>
        ///
        public int videoHeight;

        ///
        /// <summary>
        /// Current video frame rate (fps).
        /// </summary>
        ///
        public int fps;

        ///
        /// <summary>
        /// Current video bitrate (bps).
        /// </summary>
        ///
        public int videoBitrate;

        ///
        /// <summary>
        /// Current audio bitrate (bps).
        /// </summary>
        ///
        public int audioBitrate;

        public DirectCdnStreamingStats(int videoWidth, int videoHeight, int fps, int videoBitrate, int audioBitrate)
        {
            this.videoWidth = videoWidth;
            this.videoHeight = videoHeight;
            this.fps = fps;
            this.videoBitrate = videoBitrate;
            this.audioBitrate = audioBitrate;
        }
        public DirectCdnStreamingStats()
        {
        }

    }

    ///
    /// <summary>
    /// Media options for the host.
    /// 
    /// Deprecated Deprecated since v4.6.2.
    /// </summary>
    ///
    public class DirectCdnStreamingMediaOptions : IOptionalJsonParse
    {
        ///
        /// <summary>
        /// Sets whether to publish the video captured by the camera. true : Publish camera-captured video. false : (Default) Do not publish camera-captured video.
        /// </summary>
        ///
        public Optional<bool> publishCameraTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish the audio captured by the microphone. true : Publish microphone-captured audio. false : (Default) Do not publish microphone-captured audio.
        /// </summary>
        ///
        public Optional<bool> publishMicrophoneTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish custom-captured audio. true : Publish custom-captured audio. false : (Default) Do not publish custom-captured audio.
        /// </summary>
        ///
        public Optional<bool> publishCustomAudioTrack = new Optional<bool>();

        ///
        /// <summary>
        /// Sets whether to publish custom-captured video. true : Publish custom-captured video. false : (Default) Do not publish custom-captured video.
        /// </summary>
        ///
        public Optional<bool> publishCustomVideoTrack = new Optional<bool>();

        ///
        /// @ignore
        ///
        public Optional<bool> publishMediaPlayerAudioTrack = new Optional<bool>();

        ///
        /// @ignore
        ///
        public Optional<int> publishMediaPlayerId = new Optional<int>();

        ///
        /// <summary>
        /// The video track ID returned by the CreateCustomVideoTrack method. Default is 0.
        /// </summary>
        ///
        public Optional<uint> customVideoTrackId = new Optional<uint>();

        public DirectCdnStreamingMediaOptions()
        {
        }

        public DirectCdnStreamingMediaOptions(Optional<bool> publishCameraTrack, Optional<bool> publishMicrophoneTrack, Optional<bool> publishCustomAudioTrack, Optional<bool> publishCustomVideoTrack, Optional<bool> publishMediaPlayerAudioTrack, Optional<int> publishMediaPlayerId, Optional<uint> customVideoTrackId)
        {
            this.publishCameraTrack = publishCameraTrack;
            this.publishMicrophoneTrack = publishMicrophoneTrack;
            this.publishCustomAudioTrack = publishCustomAudioTrack;
            this.publishCustomVideoTrack = publishCustomVideoTrack;
            this.publishMediaPlayerAudioTrack = publishMediaPlayerAudioTrack;
            this.publishMediaPlayerId = publishMediaPlayerId;
            this.customVideoTrackId = customVideoTrackId;
        }

        ///
        /// @ignore
        ///
        public virtual void ToJson(JsonWriter writer)
        {
            writer.WriteObjectStart();

            if (this.publishCameraTrack.HasValue())
            {
                writer.WritePropertyName("publishCameraTrack");
                writer.Write(this.publishCameraTrack.GetValue());
            }

            if (this.publishMicrophoneTrack.HasValue())
            {
                writer.WritePropertyName("publishMicrophoneTrack");
                writer.Write(this.publishMicrophoneTrack.GetValue());
            }

            if (this.publishCustomAudioTrack.HasValue())
            {
                writer.WritePropertyName("publishCustomAudioTrack");
                writer.Write(this.publishCustomAudioTrack.GetValue());
            }

            if (this.publishCustomVideoTrack.HasValue())
            {
                writer.WritePropertyName("publishCustomVideoTrack");
                writer.Write(this.publishCustomVideoTrack.GetValue());
            }

            if (this.publishMediaPlayerAudioTrack.HasValue())
            {
                writer.WritePropertyName("publishMediaPlayerAudioTrack");
                writer.Write(this.publishMediaPlayerAudioTrack.GetValue());
            }

            if (this.publishMediaPlayerId.HasValue())
            {
                writer.WritePropertyName("publishMediaPlayerId");
                writer.Write(this.publishMediaPlayerId.GetValue());
            }

            if (this.customVideoTrackId.HasValue())
            {
                writer.WritePropertyName("customVideoTrackId");
                writer.Write(this.customVideoTrackId.GetValue());
            }

            writer.WriteObjectEnd();
        }
    }

    ///
    /// @ignore
    ///
    public class ExtensionInfo
    {
        ///
        /// @ignore
        ///
        public MEDIA_SOURCE_TYPE mediaSourceType;

        ///
        /// @ignore
        ///
        public uint remoteUid;

        ///
        /// @ignore
        ///
        public string channelId;

        ///
        /// @ignore
        ///
        public uint localUid;

        public ExtensionInfo()
        {
            this.mediaSourceType = MEDIA_SOURCE_TYPE.UNKNOWN_MEDIA_SOURCE;
            this.remoteUid = 0;
            this.channelId = "";
            this.localUid = 0;
        }

        public ExtensionInfo(MEDIA_SOURCE_TYPE mediaSourceType, uint remoteUid, string channelId, uint localUid)
        {
            this.mediaSourceType = mediaSourceType;
            this.remoteUid = remoteUid;
            this.channelId = channelId;
            this.localUid = localUid;
        }
    }

    ///
    /// @ignore
    ///
    public enum QUALITY_REPORT_FORMAT_TYPE
    {
        ///
        /// @ignore
        ///
        QUALITY_REPORT_JSON = 0,

        ///
        /// @ignore
        ///
        QUALITY_REPORT_HTML = 1,

    }

    ///
    /// <summary>
    /// Device state.
    /// </summary>
    ///
    public enum MEDIA_DEVICE_STATE_TYPE
    {
        ///
        /// <summary>
        /// 0: Device is ready.
        /// </summary>
        ///
        MEDIA_DEVICE_STATE_IDLE = 0,

        ///
        /// <summary>
        /// 1: Device is in use.
        /// </summary>
        ///
        MEDIA_DEVICE_STATE_ACTIVE = 1,

        ///
        /// <summary>
        /// 2: Device is disabled.
        /// </summary>
        ///
        MEDIA_DEVICE_STATE_DISABLED = 2,

        ///
        /// <summary>
        /// 3: Device is plugged in.
        /// </summary>
        ///
        MEDIA_DEVICE_STATE_PLUGGED_IN = 3,

        ///
        /// <summary>
        /// 4: Device not present.
        /// </summary>
        ///
        MEDIA_DEVICE_STATE_NOT_PRESENT = 4,

        ///
        /// <summary>
        /// 8: Device is unplugged.
        /// </summary>
        ///
        MEDIA_DEVICE_STATE_UNPLUGGED = 8,

    }

    ///
    /// @ignore
    ///
    public enum VIDEO_PROFILE_TYPE
    {
        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_120P = 0,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_120P_3 = 2,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_180P = 10,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_180P_3 = 12,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_180P_4 = 13,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_240P = 20,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_240P_3 = 22,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_240P_4 = 23,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_360P = 30,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_360P_3 = 32,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_360P_4 = 33,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_360P_6 = 35,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_360P_7 = 36,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_360P_8 = 37,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_360P_9 = 38,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_360P_10 = 39,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_360P_11 = 100,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_480P = 40,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_480P_3 = 42,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_480P_4 = 43,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_480P_6 = 45,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_480P_8 = 47,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_480P_9 = 48,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_480P_10 = 49,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_720P = 50,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_720P_3 = 52,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_720P_5 = 54,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_720P_6 = 55,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_1080P = 60,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_1080P_3 = 62,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_1080P_5 = 64,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_1440P = 66,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_1440P_2 = 67,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_4K = 70,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_LANDSCAPE_4K_3 = 72,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_120P = 1000,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_120P_3 = 1002,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_180P = 1010,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_180P_3 = 1012,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_180P_4 = 1013,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_240P = 1020,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_240P_3 = 1022,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_240P_4 = 1023,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_360P = 1030,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_360P_3 = 1032,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_360P_4 = 1033,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_360P_6 = 1035,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_360P_7 = 1036,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_360P_8 = 1037,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_360P_9 = 1038,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_360P_10 = 1039,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_360P_11 = 1100,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_480P = 1040,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_480P_3 = 1042,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_480P_4 = 1043,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_480P_6 = 1045,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_480P_8 = 1047,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_480P_9 = 1048,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_480P_10 = 1049,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_720P = 1050,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_720P_3 = 1052,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_720P_5 = 1054,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_720P_6 = 1055,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_1080P = 1060,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_1080P_3 = 1062,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_1080P_5 = 1064,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_1440P = 1066,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_1440P_2 = 1067,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_4K = 1070,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_PORTRAIT_4K_3 = 1072,

        ///
        /// @ignore
        ///
        VIDEO_PROFILE_DEFAULT = VIDEO_PROFILE_LANDSCAPE_360P,

    }

}
